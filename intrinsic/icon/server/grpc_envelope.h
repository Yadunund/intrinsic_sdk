// Copyright 2023 Intrinsic Innovation LLC

#ifndef INTRINSIC_ICON_SERVER_GRPC_ENVELOPE_H_
#define INTRINSIC_ICON_SERVER_GRPC_ENVELOPE_H_

#include <memory>
#include <optional>
#include <string>

#include "absl/base/thread_annotations.h"
#include "absl/status/status.h"
#include "absl/synchronization/mutex.h"
#include "absl/synchronization/notification.h"
#include "absl/types/optional.h"
#include "grpcpp/channel.h"
#include "grpcpp/server.h"
#include "grpcpp/support/channel_arguments.h"
#include "intrinsic/hardware/gpio/gpio_service.grpc.pb.h"
#include "intrinsic/icon/proto/autogenerated_icon_config_service.grpc.pb.h"
#include "intrinsic/icon/proto/rt_tracing_service.grpc.pb.h"
#include "intrinsic/icon/proto/service.grpc.pb.h"
#include "intrinsic/icon/server/autogenerated_icon_config_service.h"
#include "intrinsic/icon/server/service.h"
#include "intrinsic/resources/proto/resource_health.grpc.pb.h"

namespace intrinsic::icon {

// A wrapper for the ICON, GPIO grpc services and handler for the realtime
// tracing service. They either forwards calls to the wrapped services `service`
// and `gpio_service` or responds to all calls with a global error `status`.
// Each grpc server is started when the first setter function is called.
// The purpose of this is to expose error messages longer.
// Realtime tracing calls are handled directly in the wrapper to be able to
// trace ICON even if fatal errors occurred.
class GrpcEnvelope {
 public:
  struct Config {
    // Listening address of the ICON Application Layer and GPIO gRPC services.
    const std::optional<std::string> grpc_address = std::nullopt;
    // Address of the object world service. This is normally the ingress
    // address.
    const std::string object_world_address = "";
    // Address of the Resource registry service. This is normally the ingress
    // address.
    const std::string resource_registry_address = "";
    // Shared memory namespace. This is typically only used in tests.
    const std::string shared_memory_namespace = "";
  };

  explicit GrpcEnvelope(const Config& config);

  ~GrpcEnvelope();

  // ICON RPCs will be forwarded to `service`.
  // `service` must outlive GrpcEnvelope.
  void SetService(icon::IconApiService* service);

  // Gpio RPCs will be forwarded to `gpio_service`.
  // `gpio_service` must outlive GrpcEnvelope.
  void SetGpioService(
      intrinsic_proto::gpio::GPIOService::Service* gpio_service);

  // All new RPCs for both servers will respond with `status` after return.
  // This is a final state and cannot be changed by `Set*Service`.
  void SetError(absl::Status status);

  // Calls "TryCancel" on gRPC streams.
  // Usually results in all sessions closing later (after this call returns),
  // but this is not guaranteed (because of service methods not finishing for
  // other reasons or new grpc requests coming in).
  void TryCancelAllStreams();

  // 'nullptr' if ICON server has not started.
  std::shared_ptr<grpc::Channel> InProcChannel(
      const grpc::ChannelArguments& channel_args);

 private:
  class WrapperService;
  class IconHealthService;
  class GpioWrapperService;
  class RealtimeTracingService;

  void StartServer() ABSL_EXCLUSIVE_LOCKS_REQUIRED(icon_mutex_)
      ABSL_EXCLUSIVE_LOCKS_REQUIRED(gpio_mutex_);

  absl::Status GetError();

  const Config config_;

  mutable absl::Mutex error_mutex_;
  absl::Status error_ ABSL_GUARDED_BY(error_mutex_) = absl::OkStatus();

  mutable absl::Mutex icon_mutex_ ABSL_ACQUIRED_AFTER(error_mutex_);
  mutable absl::Mutex gpio_mutex_ ABSL_ACQUIRED_AFTER(icon_mutex_);
  IconApiService* service_ ABSL_GUARDED_BY(icon_mutex_) = nullptr;
  intrinsic_proto::gpio::GPIOService::Service* gpio_service_
      ABSL_GUARDED_BY(gpio_mutex_) = nullptr;

  std::unique_ptr<WrapperService> wrapper_service_;
  std::unique_ptr<IconHealthService> icon_health_service_;
  std::unique_ptr<GpioWrapperService> gpio_wrapper_service_;
  std::unique_ptr<AutoGeneratedIconConfigService>
      autogenerated_icon_config_service_;
  // Not a wrapper, as tracing does not need the same sort of "service
  // injection".
  std::unique_ptr<intrinsic_proto::icon::RealtimeTracingApi::Service>
      rt_tracing_service_;
  std::unique_ptr<::grpc::Server> server_ ABSL_GUARDED_BY(icon_mutex_)
      ABSL_GUARDED_BY(gpio_mutex_);
  absl::Notification server_started_;
};

}  // namespace intrinsic::icon

#endif  // INTRINSIC_ICON_SERVER_GRPC_ENVELOPE_H_
