// Copyright 2023 Intrinsic Innovation LLC

#include "intrinsic/icon/server/grpc_envelope.h"

#include <signal.h>

#include <memory>
#include <string>
#include <thread>  // NOLINT
#include <utility>
#include <vector>

#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/mutex.h"
#include "absl/time/clock.h"
#include "absl/time/time.h"
#include "grpc/grpc.h"
#include "grpcpp/channel.h"
#include "grpcpp/security/server_credentials.h"
#include "grpcpp/server.h"
#include "grpcpp/server_builder.h"
#include "grpcpp/server_context.h"
#include "grpcpp/support/channel_arguments.h"
#include "grpcpp/support/server_interceptor.h"
#include "grpcpp/support/status.h"
#include "grpcpp/support/sync_stream.h"
#include "intrinsic/hardware/gpio/gpio_service.grpc.pb.h"
#include "intrinsic/hardware/gpio/gpio_service.pb.h"
#include "intrinsic/icon/proto/rt_tracing_service.grpc.pb.h"
#include "intrinsic/icon/proto/rt_tracing_service.pb.h"
#include "intrinsic/icon/proto/service.grpc.pb.h"
#include "intrinsic/icon/proto/service.pb.h"
#include "intrinsic/icon/proto/types.pb.h"
#include "intrinsic/icon/server/autogenerated_icon_config_service.h"
#include "intrinsic/icon/server/service.h"
#include "intrinsic/icon/utils/exit_code.h"
#include "intrinsic/icon/utils/realtime_guard.h"
#include "intrinsic/icon/utils/shutdown_signals.h"
#include "intrinsic/resources/proto/resource_health.grpc.pb.h"
#include "intrinsic/resources/proto/resource_health.pb.h"
#include "intrinsic/resources/proto/resource_operational_status.pb.h"
#include "intrinsic/stats/opencensus.h"
#include "intrinsic/util/status/status_conversion_grpc.h"
#include "intrinsic/util/status/status_macros_grpc.h"

namespace intrinsic::icon {

class GrpcEnvelope::WrapperService : public intrinsic::icon::IconApiService {
 public:
  explicit WrapperService(GrpcEnvelope& envelope) : envelope_(envelope) {}

  ::grpc::Status GetActionSignatureByName(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetActionSignatureByNameRequest* request,
      intrinsic_proto::icon::GetActionSignatureByNameResponse* response)
      override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetActionSignatureByName(context, request,
                                                        response);
  }

  ::grpc::Status GetConfig(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetConfigRequest* request,
      intrinsic_proto::icon::GetConfigResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetConfig(context, request, response);
  }

  ::grpc::Status GetStatus(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetStatusRequest* request,
      intrinsic_proto::icon::GetStatusResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetStatus(context, request, response);
  }

  ::grpc::Status IsActionCompatible(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::IsActionCompatibleRequest* request,
      intrinsic_proto::icon::IsActionCompatibleResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->IsActionCompatible(context, request, response);
  }

  ::grpc::Status ListActionSignatures(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::ListActionSignaturesRequest* request,
      intrinsic_proto::icon::ListActionSignaturesResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->ListActionSignatures(context, request, response);
  }

  ::grpc::Status ListCompatibleParts(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::ListCompatiblePartsRequest* request,
      intrinsic_proto::icon::ListCompatiblePartsResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->ListCompatibleParts(context, request, response);
  }

  ::grpc::Status ListParts(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::ListPartsRequest* request,
      intrinsic_proto::icon::ListPartsResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->ListParts(context, request, response);
  }

  ::grpc::Status OpenSession(
      ::grpc::ServerContext* context,
      ::grpc::ServerReaderWriter<intrinsic_proto::icon::OpenSessionResponse,
                                 intrinsic_proto::icon::OpenSessionRequest>*
          stream) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->OpenSession(context, stream);
  }

  ::grpc::Status WatchReactions(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::WatchReactionsRequest* request,
      ::grpc::ServerWriter<intrinsic_proto::icon::WatchReactionsResponse>*
          writer) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->WatchReactions(context, request, writer);
  }

  ::grpc::Status OpenWriteStream(
      ::grpc::ServerContext* context,
      ::grpc::ServerReaderWriter<intrinsic_proto::icon::OpenWriteStreamResponse,
                                 intrinsic_proto::icon::OpenWriteStreamRequest>*
          stream) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->OpenWriteStream(context, stream);
  }

  ::grpc::Status GetLatestStreamingOutput(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetLatestStreamingOutputRequest* request,
      intrinsic_proto::icon::GetLatestStreamingOutputResponse* response)
      override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetLatestStreamingOutput(context, request,
                                                        response);
  }

  ::grpc::Status GetPlannedTrajectory(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetPlannedTrajectoryRequest* request,
      ::grpc::ServerWriter<intrinsic_proto::icon::GetPlannedTrajectoryResponse>*
          stream) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetPlannedTrajectory(context, request, stream);
  }

  ::grpc::Status Enable(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::EnableRequest* request,
      intrinsic_proto::icon::EnableResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->Enable(context, request, response);
  }

  ::grpc::Status Disable(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::DisableRequest* request,
      intrinsic_proto::icon::DisableResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->Disable(context, request, response);
  }

  ::grpc::Status ClearFaults(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::ClearFaultsRequest* request,
      intrinsic_proto::icon::ClearFaultsResponse* response) override {
    // If we are latching an error, then attempt to restart the server.
    if (!envelope_.GetError().ok()) {
      icon::RequestShutdownByUser(
          "Got ClearFault call while in fatal fault, restarting...",
          static_cast<int>(ExitCode::kFatalFaultDuringExec));
      return ToGrpcStatus(absl::ResourceExhaustedError(
          "The server is in a fatal fault. Will restart now, please try "
          "again."));
    }
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->ClearFaults(context, request, response);
  }

  ::grpc::Status GetOperationalStatus(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetOperationalStatusRequest* request,
      intrinsic_proto::icon::GetOperationalStatusResponse* response) override {
    if (auto error = envelope_.GetError(); !error.ok()) {
      response->mutable_operational_status()->set_state(
          intrinsic_proto::icon::OperationalState::FAULTED);
      response->mutable_operational_status()->set_fault_reason(
          error.ToString());
      return ToGrpcStatus(absl::OkStatus());
    }
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetOperationalStatus(context, request, response);
  }

  ::grpc::Status RestartServer(::grpc::ServerContext* context,
                               const google::protobuf::Empty* request,
                               google::protobuf::Empty* response) override {
    LOG(WARNING) << "PUBLIC: Received restart request, will close connections "
                    "and quit when sessions have closed.";
    std::thread terminate_thread([]() {
      absl::SleepFor(absl::Milliseconds(10));
      raise(SIGTERM);
    });
    terminate_thread.detach();
    return ToGrpcStatus(absl::OkStatus());
  }

  ::grpc::Status SetSpeedOverride(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::SetSpeedOverrideRequest* request,
      intrinsic_proto::icon::SetSpeedOverrideResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->SetSpeedOverride(context, request, response);
  }

  ::grpc::Status GetSpeedOverride(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetSpeedOverrideRequest* request,
      intrinsic_proto::icon::GetSpeedOverrideResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetSpeedOverride(context, request, response);
  }

  ::grpc::Status SetLoggingMode(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::SetLoggingModeRequest* request,
      intrinsic_proto::icon::SetLoggingModeResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->SetLoggingMode(context, request, response);
  }

  ::grpc::Status GetLoggingMode(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetLoggingModeRequest* request,
      intrinsic_proto::icon::GetLoggingModeResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetLoggingMode(context, request, response);
  }

  ::grpc::Status GetPartProperties(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetPartPropertiesRequest* request,
      intrinsic_proto::icon::GetPartPropertiesResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetPartProperties(context, request, response);
  }

  ::grpc::Status SetPartProperties(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::SetPartPropertiesRequest* request,
      intrinsic_proto::icon::SetPartPropertiesResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->SetPartProperties(context, request, response);
  }

  ::grpc::Status SetPayload(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::SetPayloadRequest* request,
      intrinsic_proto::icon::SetPayloadResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->SetPayload(context, request, response);
  }

  ::grpc::Status GetPayload(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::GetPayloadRequest* request,
      intrinsic_proto::icon::GetPayloadResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    return envelope_.service_->GetPayload(context, request, response);
  }

 private:
  GrpcEnvelope& envelope_;
};

intrinsic_proto::resources::OperationalStatus::State ConvertToHealthState(
    intrinsic_proto::icon::OperationalState state) {
  switch (state) {
    case intrinsic_proto::icon::DISABLED:
      return intrinsic_proto::resources::OperationalStatus::DISABLED;
    case intrinsic_proto::icon::FAULTED:
      return intrinsic_proto::resources::OperationalStatus::FAULTED;
    case intrinsic_proto::icon::ENABLED:
      return intrinsic_proto::resources::OperationalStatus::ENABLED;
    case intrinsic_proto::icon::UNKNOWN:
    default:
      return intrinsic_proto::resources::OperationalStatus::UNSPECIFIED;
  }
}

class GrpcEnvelope::IconHealthService
    : public intrinsic_proto::resources::ResourceHealth::Service {
 public:
  explicit IconHealthService(GrpcEnvelope& envelope) : envelope_(envelope) {}
  ~IconHealthService() override = default;

  ::grpc::Status CheckHealth(
      grpc::ServerContext* context,
      const intrinsic_proto::resources::ResourceHealthStatusRequest* request,
      intrinsic_proto::resources::ResourceHealthStatusResponse* response)
      override {
    if (auto error = envelope_.GetError(); !error.ok()) {
      response->mutable_status()->set_state(
          intrinsic_proto::resources::OperationalStatus::FAULTED);
      response->mutable_status()->set_explanation(error.ToString());
      return ToGrpcStatus(absl::OkStatus());
    }
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    const intrinsic_proto::icon::GetOperationalStatusRequest
        icon_operational_status_request;
    intrinsic_proto::icon::GetOperationalStatusResponse
        icon_operational_status_response;
    if (auto status = envelope_.service_->GetOperationalStatus(
            context, &icon_operational_status_request,
            &icon_operational_status_response);
        !status.ok()) {
      return status;
    }

    response->mutable_status()->set_state(ConvertToHealthState(
        icon_operational_status_response.operational_status().state()));

    *response->mutable_status()->mutable_explanation() =
        icon_operational_status_response.operational_status().fault_reason();
    return ToGrpcStatus(absl::OkStatus());
  }

  ::grpc::Status Enable(
      grpc::ServerContext* context,
      const intrinsic_proto::resources::ResourceEnableRequest* request,
      intrinsic_proto::resources::ResourceEnableResponse* response) override {
    return ToGrpcStatus(absl::UnavailableError(
        "Cannot enable directly. The robot controller enables automatically "
        "when no hardware module has a fault."));
  }

  ::grpc::Status Disable(
      grpc::ServerContext* context,
      const intrinsic_proto::resources::ResourceDisableRequest* request,
      intrinsic_proto::resources::ResourceDisableResponse* response) override {
    return ToGrpcStatus(absl::UnavailableError(
        "Cannot disable directly. The robot controller disables automatically "
        "when a fault is detected."));
  }

  ::grpc::Status ClearFaults(
      grpc::ServerContext* context,
      const intrinsic_proto::resources::ResourceClearFaultsRequest* request,
      intrinsic_proto::resources::ResourceClearFaultsResponse* response)
      override {
    // If we are latching an error, then attempt to restart the server.
    if (!envelope_.GetError().ok()) {
      icon::RequestShutdownByUser(
          "Got ClearFault call while in fatal fault, restarting...",
          static_cast<int>(ExitCode::kFatalFaultDuringExec));
      return ToGrpcStatus(absl::ResourceExhaustedError(
          "The server is in a fatal fault. Will restart now, please try "
          "again."));
    }
    absl::ReaderMutexLock l(&envelope_.icon_mutex_);
    if (envelope_.service_ == nullptr) {
      return ToGrpcStatus(absl::FailedPreconditionError("Service is not set."));
    }
    const intrinsic_proto::icon::ClearFaultsRequest icon_clear_faults_request;
    intrinsic_proto::icon::ClearFaultsResponse icon_clear_faults_response;
    return envelope_.service_->ClearFaults(context, &icon_clear_faults_request,
                                           &icon_clear_faults_response);
  }

 private:
  GrpcEnvelope& envelope_;
};

class GrpcEnvelope::GpioWrapperService
    : public intrinsic_proto::gpio::GPIOService::Service {
 public:
  explicit GpioWrapperService(GrpcEnvelope& envelope) : envelope_(envelope) {}

  ::grpc::Status GetSignalDescriptions(
      ::grpc::ServerContext* context,
      const intrinsic_proto::gpio::GetSignalDescriptionsRequest* request,
      intrinsic_proto::gpio::GetSignalDescriptionsResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.gpio_mutex_);
    if (envelope_.gpio_service_ == nullptr) {
      return ToGrpcStatus(
          absl::FailedPreconditionError("Gpio service is not set."));
    }
    return envelope_.gpio_service_->GetSignalDescriptions(context, request,
                                                          response);
  }

  ::grpc::Status ReadSignals(
      ::grpc::ServerContext* context,
      const intrinsic_proto::gpio::ReadSignalsRequest* request,
      intrinsic_proto::gpio::ReadSignalsResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.gpio_mutex_);
    if (envelope_.gpio_service_ == nullptr) {
      return ToGrpcStatus(
          absl::FailedPreconditionError("Gpio service is not set."));
    }
    return envelope_.gpio_service_->ReadSignals(context, request, response);
  }

  ::grpc::Status WaitForValue(
      ::grpc::ServerContext* context,
      const intrinsic_proto::gpio::WaitForValueRequest* request,
      intrinsic_proto::gpio::WaitForValueResponse* response) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.gpio_mutex_);
    if (envelope_.gpio_service_ == nullptr) {
      return ToGrpcStatus(
          absl::FailedPreconditionError("Gpio service is not set."));
    }
    return envelope_.gpio_service_->WaitForValue(context, request, response);
  }

  ::grpc::Status OpenWriteSession(
      ::grpc::ServerContext* context,
      ::grpc::ServerReaderWriter<
          intrinsic_proto::gpio::OpenWriteSessionResponse,
          intrinsic_proto::gpio::OpenWriteSessionRequest>* stream) override {
    INTR_RETURN_IF_ERROR_GRPC(envelope_.GetError());
    absl::ReaderMutexLock l(&envelope_.gpio_mutex_);
    if (envelope_.gpio_service_ == nullptr) {
      return ToGrpcStatus(
          absl::FailedPreconditionError("Gpio service is not set."));
    }
    return envelope_.gpio_service_->OpenWriteSession(context, stream);
  }

 private:
  GrpcEnvelope& envelope_;
};

class GrpcEnvelope::RealtimeTracingService
    : public intrinsic_proto::icon::RealtimeTracingApi::Service {
 public:
  ::grpc::Status StartTracing(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::StartTracingRequest* request,
      intrinsic_proto::icon::StartTracingResponse* response) override {
    return ToGrpcStatus(absl::UnimplementedError("b/370018091"));
  }

  ::grpc::Status PauseTracing(
      ::grpc::ServerContext* context,
      const intrinsic_proto::icon::PauseTracingRequest* request,
      intrinsic_proto::icon::PauseTracingResponse* response) override {
    return ToGrpcStatus(absl::UnimplementedError("b/370018091"));
  }
};

GrpcEnvelope::GrpcEnvelope(const Config& config) : config_(config) {}

GrpcEnvelope::~GrpcEnvelope() {
  absl::ReaderMutexLock l(&icon_mutex_);
  absl::ReaderMutexLock l2(&gpio_mutex_);
  if (server_) {
    server_->Shutdown();
  }
}

absl::Status GrpcEnvelope::GetError() {
  absl::MutexLock l(&error_mutex_);
  return error_;
}

void GrpcEnvelope::TryCancelAllStreams() {
  absl::ReaderMutexLock l(&icon_mutex_);
  if (service_ != nullptr) {
    service_->TryCancel();
  }
}

void GrpcEnvelope::StartServer() {
  INTRINSIC_ASSERT_NON_REALTIME();
  wrapper_service_ = std::make_unique<WrapperService>(*this);
  gpio_wrapper_service_ = std::make_unique<GpioWrapperService>(*this);
  icon_health_service_ = std::make_unique<IconHealthService>(*this);
  autogenerated_icon_config_service_ =
      std::make_unique<AutoGeneratedIconConfigService>(
          config_.shared_memory_namespace, config_.object_world_address,
          config_.resource_registry_address);
  rt_tracing_service_ = std::make_unique<RealtimeTracingService>();

  grpc::ServerBuilder builder;
  if (config_.grpc_address.has_value()) {
    builder.AddListeningPort(
        config_.grpc_address.value(),
        ::grpc::InsecureServerCredentials()  // NOLINT (insecure)
    );
  }
  // Set the max message receive size to 512MB to allow longer trajectories.
  // Please check with the motion team before changing the value (see
  // b/275280379).
  builder.SetMaxReceiveMessageSize((512 * 1024 * 1024));
  builder.AddChannelArgument(GRPC_ARG_ALLOW_REUSEPORT, 0);
  builder.AddChannelArgument(GRPC_ARG_MAX_METADATA_SIZE,
                             16 * 1024);  // Set to 16KB
  builder.RegisterService(icon_health_service_.get());
  builder.RegisterService(wrapper_service_.get());
  builder.RegisterService(gpio_wrapper_service_.get());
  builder.RegisterService(autogenerated_icon_config_service_.get());
  builder.RegisterService(rt_tracing_service_.get());

  // OpenCensusInterceptor creates metrics that can be used to detect the first
  // RPC with a given status, unlike gRPC's built-in metrics.
  std::vector<
      std::unique_ptr<grpc::experimental::ServerInterceptorFactoryInterface>>
      creators;
  creators.push_back(std::make_unique<OpenCensusInterceptorFactory>(
      intrinsic_proto::icon::IconApi::service_full_name()));
  builder.experimental().SetInterceptorCreators(std::move(creators));
  std::string server_description = "In-Process ICON Server";
  if (config_.grpc_address) {
    server_description =
        absl::StrCat("ICON Server listening on ", *config_.grpc_address);
  }
  server_ = builder.BuildAndStart();
  if (!server_) {
    LOG(FATAL) << "Failed to start " << server_description;
  }
  server_started_.Notify();
  LOG(INFO) << "Started " << server_description;
}

void GrpcEnvelope::SetService(icon::IconApiService* service) {
  absl::WriterMutexLock l(&icon_mutex_);
  absl::WriterMutexLock l2(&gpio_mutex_);
  CHECK_EQ(nullptr, server_)
      << "Cannot set grpc service, the server is already running.";
  CHECK_OK(GetError())
      << "Service already set. Overwriting service is not allowed.";
  CHECK_EQ(nullptr, service_)
      << "Service already set. Overwriting service is not allowed.";
  CHECK_NE(nullptr, service);

  service_ = service;
  StartServer();
}

void GrpcEnvelope::SetGpioService(
    intrinsic_proto::gpio::GPIOService::Service* gpio_service) {
  absl::WriterMutexLock l(&gpio_mutex_);
  CHECK_EQ(nullptr, gpio_service_)
      << "Service already set. Overwriting service is not allowed.";
  CHECK_NE(nullptr, gpio_service);

  gpio_service_ = gpio_service;
}

void GrpcEnvelope::SetError(absl::Status status) {
  {
    absl::MutexLock l(&error_mutex_);
    error_ = status;
  }
  if (!server_started_.HasBeenNotified()) {
    absl::WriterMutexLock l(&icon_mutex_);
    absl::WriterMutexLock l2(&gpio_mutex_);
    if (!server_) StartServer();
  }
}

std::shared_ptr<grpc::Channel> GrpcEnvelope::InProcChannel(
    const grpc::ChannelArguments& channel_args) {
  absl::ReaderMutexLock l(&icon_mutex_);
  absl::ReaderMutexLock l2(&gpio_mutex_);
  if (!server_) {
    return nullptr;
  }
  return server_->InProcessChannel(channel_args);
}

}  // namespace intrinsic::icon
